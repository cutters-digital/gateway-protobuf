// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/payments/payments.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// PaymentStatus contains all the possible statuses a payment can be in.
public enum Payments_PaymentStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalid // = 0
  case unknown // = 1
  case success // = 2
  case error // = 3
  case requireAction // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .unknown
    case 2: self = .success
    case 3: self = .error
    case 4: self = .requireAction
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .unknown: return 1
    case .success: return 2
    case .error: return 3
    case .requireAction: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Payments_PaymentStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Payments_PaymentStatus] = [
    .invalid,
    .unknown,
    .success,
    .error,
    .requireAction,
  ]
}

#endif  // swift(>=4.2)

/// CardStatus contains all the possible statuses a card can be in.
public enum Payments_CardStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalid // = 0
  case unknown // = 1
  case success // = 2
  case error // = 3
  case requireAction // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .unknown
    case 2: self = .success
    case 3: self = .error
    case 4: self = .requireAction
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .unknown: return 1
    case .success: return 2
    case .error: return 3
    case .requireAction: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Payments_CardStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Payments_CardStatus] = [
    .invalid,
    .unknown,
    .success,
    .error,
    .requireAction,
  ]
}

#endif  // swift(>=4.2)

/// PaymentMethod represents how customer paid for a service/product.
public enum Payments_PaymentMethod: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalid // = 0
  case unknown // = 1
  case voucher // = 2
  case stripe // = 3
  case vipps // = 4
  case wallmob // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .unknown
    case 2: self = .voucher
    case 3: self = .stripe
    case 4: self = .vipps
    case 5: self = .wallmob
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .unknown: return 1
    case .voucher: return 2
    case .stripe: return 3
    case .vipps: return 4
    case .wallmob: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Payments_PaymentMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Payments_PaymentMethod] = [
    .invalid,
    .unknown,
    .voucher,
    .stripe,
    .vipps,
    .wallmob,
  ]
}

#endif  // swift(>=4.2)

/// PaymentRequest contains information about how a payment should be done.
public struct Payments_PaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var provider: Payments_PaymentRequest.OneOf_Provider? = nil

  public var empty: Utils_Empty {
    get {
      if case .empty(let v)? = provider {return v}
      return Utils_Empty()
    }
    set {provider = .empty(newValue)}
  }

  public var stripe: Payments_StripePaymentRequest {
    get {
      if case .stripe(let v)? = provider {return v}
      return Payments_StripePaymentRequest()
    }
    set {provider = .stripe(newValue)}
  }

  public var vipps: Payments_VippsPaymentRequest {
    get {
      if case .vipps(let v)? = provider {return v}
      return Payments_VippsPaymentRequest()
    }
    set {provider = .vipps(newValue)}
  }

  public var voucher: Payments_VoucherRequest {
    get {return _voucher ?? Payments_VoucherRequest()}
    set {_voucher = newValue}
  }
  /// Returns true if `voucher` has been explicitly set.
  public var hasVoucher: Bool {return self._voucher != nil}
  /// Clears the value of `voucher`. Subsequent reads from it will return its default value.
  public mutating func clearVoucher() {self._voucher = nil}

  public var vouchers: [Payments_VoucherRequest] = []

  public var coupons: [Payments_CouponCode] = []

  /// The expected price for the payment, after discounts/vouchers. The server will not go through with payment if the expected price is different than this amount.
  public var expectedPrice: Money_Price {
    get {return _expectedPrice ?? Money_Price()}
    set {_expectedPrice = newValue}
  }
  /// Returns true if `expectedPrice` has been explicitly set.
  public var hasExpectedPrice: Bool {return self._expectedPrice != nil}
  /// Clears the value of `expectedPrice`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedPrice() {self._expectedPrice = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Provider: Equatable {
    case empty(Utils_Empty)
    case stripe(Payments_StripePaymentRequest)
    case vipps(Payments_VippsPaymentRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Payments_PaymentRequest.OneOf_Provider, rhs: Payments_PaymentRequest.OneOf_Provider) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stripe, .stripe): return {
        guard case .stripe(let l) = lhs, case .stripe(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vipps, .vipps): return {
        guard case .vipps(let l) = lhs, case .vipps(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _voucher: Payments_VoucherRequest? = nil
  fileprivate var _expectedPrice: Money_Price? = nil
}

/// CouponCode holds information needed by both requests and responses for working with cutters coupons.
public struct Payments_CouponCode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var valid: Bool = false

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// VoucherCode holds information for the app regarding the voucher information in the request.
public struct Payments_VoucherCode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var valid: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PaymentResponse contains information about the status of a payment.
public struct Payments_PaymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Payments_PaymentStatus = .invalid

  public var provider: Payments_PaymentResponse.OneOf_Provider? = nil

  public var empty: Utils_Empty {
    get {
      if case .empty(let v)? = provider {return v}
      return Utils_Empty()
    }
    set {provider = .empty(newValue)}
  }

  public var stripe: Payments_StripePaymentResponse {
    get {
      if case .stripe(let v)? = provider {return v}
      return Payments_StripePaymentResponse()
    }
    set {provider = .stripe(newValue)}
  }

  public var vipps: Payments_VippsPaymentResponse {
    get {
      if case .vipps(let v)? = provider {return v}
      return Payments_VippsPaymentResponse()
    }
    set {provider = .vipps(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Provider: Equatable {
    case empty(Utils_Empty)
    case stripe(Payments_StripePaymentResponse)
    case vipps(Payments_VippsPaymentResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Payments_PaymentResponse.OneOf_Provider, rhs: Payments_PaymentResponse.OneOf_Provider) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stripe, .stripe): return {
        guard case .stripe(let l) = lhs, case .stripe(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vipps, .vipps): return {
        guard case .vipps(let l) = lhs, case .vipps(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// VoucherRequest contains information about required fields for redeeming a voucher code.
public struct Payments_VoucherRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Code is a 6-character alphanumerical (by en-US locale) code.
  public var code: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// VoucherResponse contains information about a voucher.
public struct Payments_VoucherResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Code is a 6-character alphanumerical (by en-US locale) code.
  public var code: String = String()

  /// The voucher code might be valid only for a specific country.
  public var country: String = String()

  /// The voucher code might be valid only for a specific salon.
  public var salonID: String = String()

  /// The voucher expires at a given date+time, given in milliseconds after Unix Epoch: https://en.wikipedia.org/wiki/Unix_time
  public var expiryDate: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CardRequest contains information about how a card setup should be done.
public struct Payments_CardRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var card: Payments_Card {
    get {return _card ?? Payments_Card()}
    set {_card = newValue}
  }
  /// Returns true if `card` has been explicitly set.
  public var hasCard: Bool {return self._card != nil}
  /// Clears the value of `card`. Subsequent reads from it will return its default value.
  public mutating func clearCard() {self._card = nil}

  public var provider: Payments_CardRequest.OneOf_Provider? = nil

  public var empty: Utils_Empty {
    get {
      if case .empty(let v)? = provider {return v}
      return Utils_Empty()
    }
    set {provider = .empty(newValue)}
  }

  public var stripe: Payments_StripeCardRequest {
    get {
      if case .stripe(let v)? = provider {return v}
      return Payments_StripeCardRequest()
    }
    set {provider = .stripe(newValue)}
  }

  /// Setting error_on_not_found to true will cause the `ListCards` rpc to throw a NotFound error if no cards exists. This will be deprecated, aka default `true`, in a later version.
  public var errorOnNotFound: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Provider: Equatable {
    case empty(Utils_Empty)
    case stripe(Payments_StripeCardRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Payments_CardRequest.OneOf_Provider, rhs: Payments_CardRequest.OneOf_Provider) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stripe, .stripe): return {
        guard case .stripe(let l) = lhs, case .stripe(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
  fileprivate var _card: Payments_Card? = nil
}

/// CardResponse contains information about the status of a card.
public struct Payments_CardResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var card: Payments_Card {
    get {return _card ?? Payments_Card()}
    set {_card = newValue}
  }
  /// Returns true if `card` has been explicitly set.
  public var hasCard: Bool {return self._card != nil}
  /// Clears the value of `card`. Subsequent reads from it will return its default value.
  public mutating func clearCard() {self._card = nil}

  public var status: Payments_CardStatus = .invalid

  public var provider: Payments_CardResponse.OneOf_Provider? = nil

  public var empty: Utils_Empty {
    get {
      if case .empty(let v)? = provider {return v}
      return Utils_Empty()
    }
    set {provider = .empty(newValue)}
  }

  public var stripe: Payments_StripeCardResponse {
    get {
      if case .stripe(let v)? = provider {return v}
      return Payments_StripeCardResponse()
    }
    set {provider = .stripe(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Provider: Equatable {
    case empty(Utils_Empty)
    case stripe(Payments_StripeCardResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Payments_CardResponse.OneOf_Provider, rhs: Payments_CardResponse.OneOf_Provider) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stripe, .stripe): return {
        guard case .stripe(let l) = lhs, case .stripe(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _card: Payments_Card? = nil
}

/// Card contains information about the card.
public struct Payments_Card {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lastFourDigits: String = String()

  public var expiryYear: UInt32 = 0

  public var expiryMonth: UInt32 = 0

  public var brand: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Payments_PaymentStatus: @unchecked Sendable {}
extension Payments_CardStatus: @unchecked Sendable {}
extension Payments_PaymentMethod: @unchecked Sendable {}
extension Payments_PaymentRequest: @unchecked Sendable {}
extension Payments_PaymentRequest.OneOf_Provider: @unchecked Sendable {}
extension Payments_CouponCode: @unchecked Sendable {}
extension Payments_VoucherCode: @unchecked Sendable {}
extension Payments_PaymentResponse: @unchecked Sendable {}
extension Payments_PaymentResponse.OneOf_Provider: @unchecked Sendable {}
extension Payments_VoucherRequest: @unchecked Sendable {}
extension Payments_VoucherResponse: @unchecked Sendable {}
extension Payments_CardRequest: @unchecked Sendable {}
extension Payments_CardRequest.OneOf_Provider: @unchecked Sendable {}
extension Payments_CardResponse: @unchecked Sendable {}
extension Payments_CardResponse.OneOf_Provider: @unchecked Sendable {}
extension Payments_Card: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "payments"

extension Payments_PaymentStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAYMENT_STATUS_INVALID"),
    1: .same(proto: "PAYMENT_STATUS_UNKNOWN"),
    2: .same(proto: "PAYMENT_STATUS_SUCCESS"),
    3: .same(proto: "PAYMENT_STATUS_ERROR"),
    4: .same(proto: "PAYMENT_STATUS_REQUIRE_ACTION"),
  ]
}

extension Payments_CardStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CARD_STATUS_INVALID"),
    1: .same(proto: "CARD_STATUS_UNKNOWN"),
    2: .same(proto: "CARD_STATUS_SUCCESS"),
    3: .same(proto: "CARD_STATUS_ERROR"),
    4: .same(proto: "CARD_STATUS_REQUIRE_ACTION"),
  ]
}

extension Payments_PaymentMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAYMENT_METHOD_INVALID"),
    1: .same(proto: "PAYMENT_METHOD_UNKNOWN"),
    2: .same(proto: "PAYMENT_METHOD_VOUCHER"),
    3: .same(proto: "PAYMENT_METHOD_STRIPE"),
    4: .same(proto: "PAYMENT_METHOD_VIPPS"),
    5: .same(proto: "PAYMENT_METHOD_WALLMOB"),
  ]
}

extension Payments_PaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "empty"),
    2: .same(proto: "stripe"),
    5: .same(proto: "vipps"),
    3: .same(proto: "voucher"),
    6: .same(proto: "vouchers"),
    7: .same(proto: "coupons"),
    4: .standard(proto: "expected_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Utils_Empty?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .empty(v)
        }
      }()
      case 2: try {
        var v: Payments_StripePaymentRequest?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .stripe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .stripe(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._voucher) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expectedPrice) }()
      case 5: try {
        var v: Payments_VippsPaymentRequest?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .vipps(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .vipps(v)
        }
      }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.vouchers) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.coupons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.provider {
    case .empty?: try {
      guard case .empty(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stripe?: try {
      guard case .stripe(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    default: break
    }
    try { if let v = self._voucher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expectedPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if case .vipps(let v)? = self.provider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.vouchers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vouchers, fieldNumber: 6)
    }
    if !self.coupons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coupons, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_PaymentRequest, rhs: Payments_PaymentRequest) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs._voucher != rhs._voucher {return false}
    if lhs.vouchers != rhs.vouchers {return false}
    if lhs.coupons != rhs.coupons {return false}
    if lhs._expectedPrice != rhs._expectedPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payments_CouponCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CouponCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "valid"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_CouponCode, rhs: Payments_CouponCode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payments_VoucherCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoucherCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "valid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_VoucherCode, rhs: Payments_VoucherCode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payments_PaymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "empty"),
    3: .same(proto: "stripe"),
    4: .same(proto: "vipps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try {
        var v: Utils_Empty?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .empty(v)
        }
      }()
      case 3: try {
        var v: Payments_StripePaymentResponse?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .stripe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .stripe(v)
        }
      }()
      case 4: try {
        var v: Payments_VippsPaymentResponse?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .vipps(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .vipps(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .invalid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    switch self.provider {
    case .empty?: try {
      guard case .empty(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stripe?: try {
      guard case .stripe(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .vipps?: try {
      guard case .vipps(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_PaymentResponse, rhs: Payments_PaymentResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payments_VoucherRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoucherRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_VoucherRequest, rhs: Payments_VoucherRequest) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payments_VoucherResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoucherResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "country"),
    3: .standard(proto: "salon_id"),
    4: .standard(proto: "expiry_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expiryDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 2)
    }
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 3)
    }
    if self.expiryDate != 0 {
      try visitor.visitSingularInt64Field(value: self.expiryDate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_VoucherResponse, rhs: Payments_VoucherResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.country != rhs.country {return false}
    if lhs.salonID != rhs.salonID {return false}
    if lhs.expiryDate != rhs.expiryDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payments_CardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "card"),
    3: .same(proto: "empty"),
    4: .same(proto: "stripe"),
    17: .standard(proto: "error_on_not_found"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._card) }()
      case 3: try {
        var v: Utils_Empty?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .empty(v)
        }
      }()
      case 4: try {
        var v: Payments_StripeCardRequest?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .stripe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .stripe(v)
        }
      }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.errorOnNotFound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._card {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.provider {
    case .empty?: try {
      guard case .empty(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .stripe?: try {
      guard case .stripe(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.errorOnNotFound != false {
      try visitor.visitSingularBoolField(value: self.errorOnNotFound, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_CardRequest, rhs: Payments_CardRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._card != rhs._card {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.errorOnNotFound != rhs.errorOnNotFound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payments_CardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
    2: .same(proto: "status"),
    3: .same(proto: "empty"),
    4: .same(proto: "stripe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._card) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try {
        var v: Utils_Empty?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .empty(v)
        }
      }()
      case 4: try {
        var v: Payments_StripeCardResponse?
        var hadOneofValue = false
        if let current = self.provider {
          hadOneofValue = true
          if case .stripe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.provider = .stripe(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._card {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != .invalid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    switch self.provider {
    case .empty?: try {
      guard case .empty(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .stripe?: try {
      guard case .stripe(let v)? = self.provider else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_CardResponse, rhs: Payments_CardResponse) -> Bool {
    if lhs._card != rhs._card {return false}
    if lhs.status != rhs.status {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payments_Card: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Card"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_four_digits"),
    2: .standard(proto: "expiry_year"),
    3: .standard(proto: "expiry_month"),
    4: .same(proto: "brand"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lastFourDigits) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.expiryYear) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.expiryMonth) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastFourDigits.isEmpty {
      try visitor.visitSingularStringField(value: self.lastFourDigits, fieldNumber: 1)
    }
    if self.expiryYear != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiryYear, fieldNumber: 2)
    }
    if self.expiryMonth != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiryMonth, fieldNumber: 3)
    }
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Payments_Card, rhs: Payments_Card) -> Bool {
    if lhs.lastFourDigits != rhs.lastFourDigits {return false}
    if lhs.expiryYear != rhs.expiryYear {return false}
    if lhs.expiryMonth != rhs.expiryMonth {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
