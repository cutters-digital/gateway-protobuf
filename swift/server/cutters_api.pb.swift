// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/server/cutters_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// HistoricalTransactionState contains valid states for historical service transactions.
public enum Server_HistoricalTransactionState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case completed // = 1
  case cancelled // = 2
  case noshow // = 3
  case error // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .completed
    case 2: self = .cancelled
    case 3: self = .noshow
    case 4: self = .error
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .completed: return 1
    case .cancelled: return 2
    case .noshow: return 3
    case .error: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Server_HistoricalTransactionState] = [
    .invalid,
    .completed,
    .cancelled,
    .noshow,
    .error,
  ]

}

/// BookingStatus contains all the known statuses a booking can be in.
public enum Server_BookingStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case unknown // = 1
  case registered // = 2
  case started // = 3
  case stopped // = 4
  case serving // = 5
  case noshow // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .unknown
    case 2: self = .registered
    case 3: self = .started
    case 4: self = .stopped
    case 5: self = .serving
    case 6: self = .noshow
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .unknown: return 1
    case .registered: return 2
    case .started: return 3
    case .stopped: return 4
    case .serving: return 5
    case .noshow: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Server_BookingStatus] = [
    .invalid,
    .unknown,
    .registered,
    .started,
    .stopped,
    .serving,
    .noshow,
  ]

}

/// ServiceStatus contains all the known statuses a service-purchase can be in.
public enum Server_ServiceStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0

  /// Order complete = We have received payment, and are putting the customer in queue.
  case orderComplete // = 2

  /// Waiting = You are currently in queue, but it is a while until your cut.
  case waiting // = 3

  /// Almost ready = You are in queue, and it's about to be your turn. Time to get to the salon.
  case almostReady // = 4

  /// Your turn = You are in queue, and it's your turn to be served.
  case yourTurn // = 5

  /// Completed = Your cut is completed, or was canceled.
  case completed // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 2: self = .orderComplete
    case 3: self = .waiting
    case 4: self = .almostReady
    case 5: self = .yourTurn
    case 6: self = .completed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .orderComplete: return 2
    case .waiting: return 3
    case .almostReady: return 4
    case .yourTurn: return 5
    case .completed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Server_ServiceStatus] = [
    .invalid,
    .orderComplete,
    .waiting,
    .almostReady,
    .yourTurn,
    .completed,
  ]

}

/// WaitingTimePrecision contains all the known precisions of a salon's waiting-time.
public enum Server_WaitingTimePrecision: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0

  /// We don't know the waiting-time.
  case unknown // = 1

  /// We know approximately what the waiting-time is.
  case approximate // = 2

  /// There is little to no waiting-time.
  case none // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .unknown
    case 2: self = .approximate
    case 3: self = .none
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .unknown: return 1
    case .approximate: return 2
    case .none: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Server_WaitingTimePrecision] = [
    .invalid,
    .unknown,
    .approximate,
    .none,
  ]

}

public struct Server_AvailableHairdressersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var salonID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_AvailableHairdressersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var anonymousHairdressers: Int32 = 0

  public var hairdressers: [Server_Hairdresser] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Hairdresser describes a non-anonymous, punched-in worker.
public struct Server_Hairdresser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var displayName: String = String()

  public var initials: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GetWaitingTimesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Server_GetWaitingTimesRequest.OneOf_Mode? = nil

  public var empty: Utils_Empty {
    get {
      if case .empty(let v)? = mode {return v}
      return Utils_Empty()
    }
    set {mode = .empty(newValue)}
  }

  public var location: Server_Location {
    get {
      if case .location(let v)? = mode {return v}
      return Server_Location()
    }
    set {mode = .location(newValue)}
  }

  public var locales: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Mode: Equatable, Sendable {
    case empty(Utils_Empty)
    case location(Server_Location)

  }

  public init() {}
}

public struct Server_GetWaitingTimesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var salon: Server_Salon {
    get {return _salon ?? Server_Salon()}
    set {_salon = newValue}
  }
  /// Returns true if `salon` has been explicitly set.
  public var hasSalon: Bool {return self._salon != nil}
  /// Clears the value of `salon`. Subsequent reads from it will return its default value.
  public mutating func clearSalon() {self._salon = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _salon: Server_Salon? = nil
}

public struct Server_GetSalonRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var salonID: String = String()

  public var locales: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GetSalonResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var salon: Server_Salon {
    get {return _salon ?? Server_Salon()}
    set {_salon = newValue}
  }
  /// Returns true if `salon` has been explicitly set.
  public var hasSalon: Bool {return self._salon != nil}
  /// Clears the value of `salon`. Subsequent reads from it will return its default value.
  public mutating func clearSalon() {self._salon = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _salon: Server_Salon? = nil
}

public struct Server_BookRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var salonID: String = String()

  public var products: [Products_Product] = []

  public var payment: Payments_PaymentRequest {
    get {return _payment ?? Payments_PaymentRequest()}
    set {_payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return self._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {self._payment = nil}

  /// Setting allow_async to true will cause the `Book` rpc to be a lot quicker, but will rather contain a `transaction_id` in the `BookingDetails` instead of a `url`. This will be deprecated, aka default `true`, in a later version.
  public var allowAsync: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
  fileprivate var _payment: Payments_PaymentRequest? = nil
}

public struct Server_BookResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payment: Payments_PaymentResponse {
    get {return _payment ?? Payments_PaymentResponse()}
    set {_payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return self._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {self._payment = nil}

  public var booking: Server_BookingDetails {
    get {return _booking ?? Server_BookingDetails()}
    set {_booking = newValue}
  }
  /// Returns true if `booking` has been explicitly set.
  public var hasBooking: Bool {return self._booking != nil}
  /// Clears the value of `booking`. Subsequent reads from it will return its default value.
  public mutating func clearBooking() {self._booking = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payment: Payments_PaymentResponse? = nil
  fileprivate var _booking: Server_BookingDetails? = nil
}

public struct Server_PurchaseRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _storage._auth ?? Auth_Authentication()}
    set {_uniqueStorage()._auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return _storage._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {_uniqueStorage()._auth = nil}

  public var salonID: String {
    get {return _storage._salonID}
    set {_uniqueStorage()._salonID = newValue}
  }

  public var services: [Products_ServiceRequest] {
    get {return _storage._services}
    set {_uniqueStorage()._services = newValue}
  }

  public var products: [Products_ProductRequest] {
    get {return _storage._products}
    set {_uniqueStorage()._products = newValue}
  }

  public var payment: Payments_PaymentRequest {
    get {return _storage._payment ?? Payments_PaymentRequest()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {_uniqueStorage()._payment = nil}

  /// If aware_of_campaigns is set, then the gateway will apply campaigns when calculating the price.
  public var awareOfCampaigns: Bool {
    get {return _storage._awareOfCampaigns}
    set {_uniqueStorage()._awareOfCampaigns = newValue}
  }

  public var idempotencyKey: String {
    get {return _storage._idempotencyKey}
    set {_uniqueStorage()._idempotencyKey = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Server_PurchaseResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payment: Payments_PaymentResponse {
    get {return _payment ?? Payments_PaymentResponse()}
    set {_payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  public var hasPayment: Bool {return self._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  public mutating func clearPayment() {self._payment = nil}

  public var bookings: [Server_BookingDetails] = []

  public var idempotencyKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payment: Payments_PaymentResponse? = nil
}

public struct Server_GetAvailablePaymentProvidersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_GetAvailablePaymentProvidersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The currently available payment solutions for this user.
  public var providers: Server_AvailablePaymentProviders {
    get {return _providers ?? Server_AvailablePaymentProviders()}
    set {_providers = newValue}
  }
  /// Returns true if `providers` has been explicitly set.
  public var hasProviders: Bool {return self._providers != nil}
  /// Clears the value of `providers`. Subsequent reads from it will return its default value.
  public mutating func clearProviders() {self._providers = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _providers: Server_AvailablePaymentProviders? = nil
}

public struct Server_GetPriceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var salonID: String = String()

  public var services: [Products_ServiceRequest] = []

  public var products: [Products_ProductRequest] = []

  public var voucher: Payments_VoucherRequest {
    get {return _voucher ?? Payments_VoucherRequest()}
    set {_voucher = newValue}
  }
  /// Returns true if `voucher` has been explicitly set.
  public var hasVoucher: Bool {return self._voucher != nil}
  /// Clears the value of `voucher`. Subsequent reads from it will return its default value.
  public mutating func clearVoucher() {self._voucher = nil}

  public var vouchers: [Payments_VoucherRequest] = []

  public var coupons: [Payments_CouponCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
  fileprivate var _voucher: Payments_VoucherRequest? = nil
}

public struct Server_GetPriceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var price: Money_Price {
    get {return _price ?? Money_Price()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  public var coupons: [Payments_CouponCode] = []

  public var vouchers: [Payments_VoucherCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Money_Price? = nil
}

public struct Server_GetCampaignsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var salonID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_GetCampaignsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// active_campaign will be true if there is an active campaign matching the request.
  public var activeCampaign: Bool = false

  public var campaignText: String = String()

  /// The dialog title/message should be shown if they are both non-empty.
  public var campaignDialogTitle: String = String()

  public var campaignDialogMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GetServicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var salonID: String = String()

  public var locales: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GetServicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var service: Products_Service {
    get {return _service ?? Products_Service()}
    set {_service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  public var hasService: Bool {return self._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  public mutating func clearService() {self._service = nil}

  /// available_count will reflect how many of this specific service can be purchased.
  public var availableCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _service: Products_Service? = nil
}

public struct Server_GetProductsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var salonID: String = String()

  public var locales: [String] = []

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_GetProductsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var product: Products_Product {
    get {return _product ?? Products_Product()}
    set {_product = newValue}
  }
  /// Returns true if `product` has been explicitly set.
  public var hasProduct: Bool {return self._product != nil}
  /// Clears the value of `product`. Subsequent reads from it will return its default value.
  public mutating func clearProduct() {self._product = nil}

  public var stockCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _product: Products_Product? = nil
}

public struct Server_GetWaitingStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  /// transaction_id should be a Transaction connected to a Service, not a Product.
  public var transactionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_GetWaitingStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var booking: Server_BookingDetails {
    get {return _booking ?? Server_BookingDetails()}
    set {_booking = newValue}
  }
  /// Returns true if `booking` has been explicitly set.
  public var hasBooking: Bool {return self._booking != nil}
  /// Clears the value of `booking`. Subsequent reads from it will return its default value.
  public mutating func clearBooking() {self._booking = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _booking: Server_BookingDetails? = nil
}

public struct Server_ListTransactionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var includeActive: Bool = false

  public var includeHistoric: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_ListTransactionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeServices: [Server_ServiceTransaction] = []

  public var activeProducts: [Server_ProductTransaction] = []

  public var historicServices: [Server_ServiceTransaction] = []

  public var historicProducts: [Server_ProductTransaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_CanRedeemVoucherRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var voucher: Payments_VoucherRequest {
    get {return _voucher ?? Payments_VoucherRequest()}
    set {_voucher = newValue}
  }
  /// Returns true if `voucher` has been explicitly set.
  public var hasVoucher: Bool {return self._voucher != nil}
  /// Clears the value of `voucher`. Subsequent reads from it will return its default value.
  public mutating func clearVoucher() {self._voucher = nil}

  public var salonID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
  fileprivate var _voucher: Payments_VoucherRequest? = nil
}

public struct Server_CanRedeemVoucherResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var canRedeem: Bool = false

  /// If the voucher could not be redeemed, the localized reason will be set.
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_CreateVoucherRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_CreateVoucherResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var voucher: Payments_VoucherResponse {
    get {return _voucher ?? Payments_VoucherResponse()}
    set {_voucher = newValue}
  }
  /// Returns true if `voucher` has been explicitly set.
  public var hasVoucher: Bool {return self._voucher != nil}
  /// Clears the value of `voucher`. Subsequent reads from it will return its default value.
  public mutating func clearVoucher() {self._voucher = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _voucher: Payments_VoucherResponse? = nil
}

public struct Server_GetReferralStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_GetReferralStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var currentReferralCount: UInt32 = 0

  public var targetReferralCount: UInt32 = 0

  public var voucher: [Payments_VoucherResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_CancelServiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  /// transaction_id should be a Transaction connected to a Service, not a Product.
  public var transactionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_CancelServiceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_RemoteLogRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var event: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_RemoteLogResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_TimeoutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seconds: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_TimeoutResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ListActiveTransactionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
}

public struct Server_ListActiveTransactionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serviceTransactions: [Server_ActiveServiceTransaction] = []

  public var productTransactions: [Server_ActiveProductTransaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ListHistoricalTransactionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Auth_Authentication {
    get {return _auth ?? Auth_Authentication()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var since: Utils_Timestamp {
    get {return _since ?? Utils_Timestamp()}
    set {_since = newValue}
  }
  /// Returns true if `since` has been explicitly set.
  public var hasSince: Bool {return self._since != nil}
  /// Clears the value of `since`. Subsequent reads from it will return its default value.
  public mutating func clearSince() {self._since = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _auth: Auth_Authentication? = nil
  fileprivate var _since: Utils_Timestamp? = nil
}

public struct Server_ListHistoricalTransactionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serviceTransactions: [Server_HistoricalServiceTransaction] = []

  public var productTransactions: [Server_HistoricalProductTransaction] = []

  public var daysSinceLastHaircut: Int32 = 0

  public var daysSinceLastHaircutPictureURL: String = String()

  public var daysSinceLastHaircutText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BookingDetails contains information about the status of the booking.
public struct Server_BookingDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  public var url: String = String()

  /// Estimated waiting-time, given in milliseconds.
  public var waitingTime: Int32 = 0

  public var transactionID: String = String()

  /// NOTE: This field was marked as deprecated in the .proto file.
  public var status: Server_BookingStatus = .invalid

  public var positionInQueue: Int32 = 0

  public var queueURL: String = String()

  public var serviceStatus: Server_ServiceStatus = .invalid

  public var estimatedWait: Server_ReadableWaitingTime {
    get {return _estimatedWait ?? Server_ReadableWaitingTime()}
    set {_estimatedWait = newValue}
  }
  /// Returns true if `estimatedWait` has been explicitly set.
  public var hasEstimatedWait: Bool {return self._estimatedWait != nil}
  /// Clears the value of `estimatedWait`. Subsequent reads from it will return its default value.
  public mutating func clearEstimatedWait() {self._estimatedWait = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _estimatedWait: Server_ReadableWaitingTime? = nil
}

/// OpeningTime describes opening-hours.
public struct Server_OpeningTime: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A boolean indicating whether the salon is open or not.
  public var `open`: Bool = false

  /// Opening-time, given as milliseconds after midnight.
  public var from: UInt32 = 0

  /// Closing-time, given as milliseconds after midnight.
  public var to: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Timetable describes the opening-times for a week.
public struct Server_Timetable: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mon: Server_OpeningTime {
    get {return _storage._mon ?? Server_OpeningTime()}
    set {_uniqueStorage()._mon = newValue}
  }
  /// Returns true if `mon` has been explicitly set.
  public var hasMon: Bool {return _storage._mon != nil}
  /// Clears the value of `mon`. Subsequent reads from it will return its default value.
  public mutating func clearMon() {_uniqueStorage()._mon = nil}

  public var tue: Server_OpeningTime {
    get {return _storage._tue ?? Server_OpeningTime()}
    set {_uniqueStorage()._tue = newValue}
  }
  /// Returns true if `tue` has been explicitly set.
  public var hasTue: Bool {return _storage._tue != nil}
  /// Clears the value of `tue`. Subsequent reads from it will return its default value.
  public mutating func clearTue() {_uniqueStorage()._tue = nil}

  public var wed: Server_OpeningTime {
    get {return _storage._wed ?? Server_OpeningTime()}
    set {_uniqueStorage()._wed = newValue}
  }
  /// Returns true if `wed` has been explicitly set.
  public var hasWed: Bool {return _storage._wed != nil}
  /// Clears the value of `wed`. Subsequent reads from it will return its default value.
  public mutating func clearWed() {_uniqueStorage()._wed = nil}

  public var thu: Server_OpeningTime {
    get {return _storage._thu ?? Server_OpeningTime()}
    set {_uniqueStorage()._thu = newValue}
  }
  /// Returns true if `thu` has been explicitly set.
  public var hasThu: Bool {return _storage._thu != nil}
  /// Clears the value of `thu`. Subsequent reads from it will return its default value.
  public mutating func clearThu() {_uniqueStorage()._thu = nil}

  public var fri: Server_OpeningTime {
    get {return _storage._fri ?? Server_OpeningTime()}
    set {_uniqueStorage()._fri = newValue}
  }
  /// Returns true if `fri` has been explicitly set.
  public var hasFri: Bool {return _storage._fri != nil}
  /// Clears the value of `fri`. Subsequent reads from it will return its default value.
  public mutating func clearFri() {_uniqueStorage()._fri = nil}

  public var sat: Server_OpeningTime {
    get {return _storage._sat ?? Server_OpeningTime()}
    set {_uniqueStorage()._sat = newValue}
  }
  /// Returns true if `sat` has been explicitly set.
  public var hasSat: Bool {return _storage._sat != nil}
  /// Clears the value of `sat`. Subsequent reads from it will return its default value.
  public mutating func clearSat() {_uniqueStorage()._sat = nil}

  public var sun: Server_OpeningTime {
    get {return _storage._sun ?? Server_OpeningTime()}
    set {_uniqueStorage()._sun = newValue}
  }
  /// Returns true if `sun` has been explicitly set.
  public var hasSun: Bool {return _storage._sun != nil}
  /// Clears the value of `sun`. Subsequent reads from it will return its default value.
  public mutating func clearSun() {_uniqueStorage()._sun = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Salon describes the information about a salon.
public struct Server_Salon: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Estimated waiting-time, given in milliseconds.
  public var waitingTime: Int32 {
    get {return _storage._waitingTime}
    set {_uniqueStorage()._waitingTime = newValue}
  }

  public var inQueue: UInt32 {
    get {return _storage._inQueue}
    set {_uniqueStorage()._inQueue = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var city: String {
    get {return _storage._city}
    set {_uniqueStorage()._city = newValue}
  }

  public var country: String {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var postNumber: String {
    get {return _storage._postNumber}
    set {_uniqueStorage()._postNumber = newValue}
  }

  public var post: String {
    get {return _storage._post}
    set {_uniqueStorage()._post = newValue}
  }

  public var phone: String {
    get {return _storage._phone}
    set {_uniqueStorage()._phone = newValue}
  }

  public var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  public var times: Server_Timetable {
    get {return _storage._times ?? Server_Timetable()}
    set {_uniqueStorage()._times = newValue}
  }
  /// Returns true if `times` has been explicitly set.
  public var hasTimes: Bool {return _storage._times != nil}
  /// Clears the value of `times`. Subsequent reads from it will return its default value.
  public mutating func clearTimes() {_uniqueStorage()._times = nil}

  public var `open`: Bool {
    get {return _storage._open}
    set {_uniqueStorage()._open = newValue}
  }

  public var location: Server_Location {
    get {return _storage._location ?? Server_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  public var haircutPrice: Money_Price {
    get {return _storage._haircutPrice ?? Money_Price()}
    set {_uniqueStorage()._haircutPrice = newValue}
  }
  /// Returns true if `haircutPrice` has been explicitly set.
  public var hasHaircutPrice: Bool {return _storage._haircutPrice != nil}
  /// Clears the value of `haircutPrice`. Subsequent reads from it will return its default value.
  public mutating func clearHaircutPrice() {_uniqueStorage()._haircutPrice = nil}

  /// Relative location is a short snippet about where the salon is located, e.g. under the escalator in the 2nd floor.
  public var relativeLocation: String {
    get {return _storage._relativeLocation}
    set {_uniqueStorage()._relativeLocation = newValue}
  }

  /// The currency the salon uses.
  public var currency: Money_Currency {
    get {return _storage._currency ?? Money_Currency()}
    set {_uniqueStorage()._currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  public var hasCurrency: Bool {return _storage._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  public mutating func clearCurrency() {_uniqueStorage()._currency = nil}

  /// The phone-prefix to use when registering users, such as "+47" or "+46".
  public var defaultPhonePrefix: String {
    get {return _storage._defaultPhonePrefix}
    set {_uniqueStorage()._defaultPhonePrefix = newValue}
  }

  public var estimatedWait: Server_ReadableWaitingTime {
    get {return _storage._estimatedWait ?? Server_ReadableWaitingTime()}
    set {_uniqueStorage()._estimatedWait = newValue}
  }
  /// Returns true if `estimatedWait` has been explicitly set.
  public var hasEstimatedWait: Bool {return _storage._estimatedWait != nil}
  /// Clears the value of `estimatedWait`. Subsequent reads from it will return its default value.
  public mutating func clearEstimatedWait() {_uniqueStorage()._estimatedWait = nil}

  /// Precision of the waiting-time.
  public var precision: Server_WaitingTimePrecision {
    get {return _storage._precision}
    set {_uniqueStorage()._precision = newValue}
  }

  /// The currently available payment solutions for this salon.
  public var providers: Server_AvailablePaymentProviders {
    get {return _storage._providers ?? Server_AvailablePaymentProviders()}
    set {_uniqueStorage()._providers = newValue}
  }
  /// Returns true if `providers` has been explicitly set.
  public var hasProviders: Bool {return _storage._providers != nil}
  /// Clears the value of `providers`. Subsequent reads from it will return its default value.
  public mutating func clearProviders() {_uniqueStorage()._providers = nil}

  /// Is referring enabled for this salon
  public var isReferringEnabled: Bool {
    get {return _storage._isReferringEnabled}
    set {_uniqueStorage()._isReferringEnabled = newValue}
  }

  public var availableHairdressers: Server_AvailableHairdressersResponse {
    get {return _storage._availableHairdressers ?? Server_AvailableHairdressersResponse()}
    set {_uniqueStorage()._availableHairdressers = newValue}
  }
  /// Returns true if `availableHairdressers` has been explicitly set.
  public var hasAvailableHairdressers: Bool {return _storage._availableHairdressers != nil}
  /// Clears the value of `availableHairdressers`. Subsequent reads from it will return its default value.
  public mutating func clearAvailableHairdressers() {_uniqueStorage()._availableHairdressers = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Location describes a geo-location on earth, given in Decimal degrees: https://en.wikipedia.org/wiki/Decimal_degrees
public struct Server_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lat: Double = 0

  public var lng: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ServiceTransaction describes a purchased service.
public struct Server_ServiceTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Service Transaction-ID: Used to get Waiting-status.
  public var id: String = String()

  public var registeredTime: Utils_Timestamp {
    get {return _registeredTime ?? Utils_Timestamp()}
    set {_registeredTime = newValue}
  }
  /// Returns true if `registeredTime` has been explicitly set.
  public var hasRegisteredTime: Bool {return self._registeredTime != nil}
  /// Clears the value of `registeredTime`. Subsequent reads from it will return its default value.
  public mutating func clearRegisteredTime() {self._registeredTime = nil}

  public var paymentTime: Utils_Timestamp {
    get {return _paymentTime ?? Utils_Timestamp()}
    set {_paymentTime = newValue}
  }
  /// Returns true if `paymentTime` has been explicitly set.
  public var hasPaymentTime: Bool {return self._paymentTime != nil}
  /// Clears the value of `paymentTime`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentTime() {self._paymentTime = nil}

  public var startedTime: Utils_Timestamp {
    get {return _startedTime ?? Utils_Timestamp()}
    set {_startedTime = newValue}
  }
  /// Returns true if `startedTime` has been explicitly set.
  public var hasStartedTime: Bool {return self._startedTime != nil}
  /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartedTime() {self._startedTime = nil}

  public var completedTime: Utils_Timestamp {
    get {return _completedTime ?? Utils_Timestamp()}
    set {_completedTime = newValue}
  }
  /// Returns true if `completedTime` has been explicitly set.
  public var hasCompletedTime: Bool {return self._completedTime != nil}
  /// Clears the value of `completedTime`. Subsequent reads from it will return its default value.
  public mutating func clearCompletedTime() {self._completedTime = nil}

  /// The service that was purchased.
  public var service: Products_Service {
    get {return _service ?? Products_Service()}
    set {_service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  public var hasService: Bool {return self._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  public mutating func clearService() {self._service = nil}

  /// Which salon the purchase was at.
  public var salonID: String = String()

  /// The name of the customer. Might be "Name 1" or "Name 2" if the customer purchased multiple haircuts at the same time.
  public var customerName: String = String()

  public var queueURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _registeredTime: Utils_Timestamp? = nil
  fileprivate var _paymentTime: Utils_Timestamp? = nil
  fileprivate var _startedTime: Utils_Timestamp? = nil
  fileprivate var _completedTime: Utils_Timestamp? = nil
  fileprivate var _service: Products_Service? = nil
}

/// ProductTransaction describes a purchased product.
public struct Server_ProductTransaction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Product Transaction-ID: Used when registering a product as picked up.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var registeredTime: Utils_Timestamp {
    get {return _storage._registeredTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._registeredTime = newValue}
  }
  /// Returns true if `registeredTime` has been explicitly set.
  public var hasRegisteredTime: Bool {return _storage._registeredTime != nil}
  /// Clears the value of `registeredTime`. Subsequent reads from it will return its default value.
  public mutating func clearRegisteredTime() {_uniqueStorage()._registeredTime = nil}

  public var paymentTime: Utils_Timestamp {
    get {return _storage._paymentTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._paymentTime = newValue}
  }
  /// Returns true if `paymentTime` has been explicitly set.
  public var hasPaymentTime: Bool {return _storage._paymentTime != nil}
  /// Clears the value of `paymentTime`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentTime() {_uniqueStorage()._paymentTime = nil}

  public var startedTime: Utils_Timestamp {
    get {return _storage._startedTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._startedTime = newValue}
  }
  /// Returns true if `startedTime` has been explicitly set.
  public var hasStartedTime: Bool {return _storage._startedTime != nil}
  /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

  public var completedTime: Utils_Timestamp {
    get {return _storage._completedTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._completedTime = newValue}
  }
  /// Returns true if `completedTime` has been explicitly set.
  public var hasCompletedTime: Bool {return _storage._completedTime != nil}
  /// Clears the value of `completedTime`. Subsequent reads from it will return its default value.
  public mutating func clearCompletedTime() {_uniqueStorage()._completedTime = nil}

  /// The service that was purchased.
  public var product: Products_Product {
    get {return _storage._product ?? Products_Product()}
    set {_uniqueStorage()._product = newValue}
  }
  /// Returns true if `product` has been explicitly set.
  public var hasProduct: Bool {return _storage._product != nil}
  /// Clears the value of `product`. Subsequent reads from it will return its default value.
  public mutating func clearProduct() {_uniqueStorage()._product = nil}

  /// Which salon the purchase was at.
  public var salonID: String {
    get {return _storage._salonID}
    set {_uniqueStorage()._salonID = newValue}
  }

  /// How many of the same product is tied to the same product-purchase-id.
  public var quantity: UInt32 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ServiceTransaction describes a purchased service.
public struct Server_ActiveServiceTransaction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Service Transaction-ID: Used to get Waiting-status.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var batchID: String {
    get {return _storage._batchID}
    set {_uniqueStorage()._batchID = newValue}
  }

  public var registeredTime: Utils_Timestamp {
    get {return _storage._registeredTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._registeredTime = newValue}
  }
  /// Returns true if `registeredTime` has been explicitly set.
  public var hasRegisteredTime: Bool {return _storage._registeredTime != nil}
  /// Clears the value of `registeredTime`. Subsequent reads from it will return its default value.
  public mutating func clearRegisteredTime() {_uniqueStorage()._registeredTime = nil}

  public var paymentTime: Utils_Timestamp {
    get {return _storage._paymentTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._paymentTime = newValue}
  }
  /// Returns true if `paymentTime` has been explicitly set.
  public var hasPaymentTime: Bool {return _storage._paymentTime != nil}
  /// Clears the value of `paymentTime`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentTime() {_uniqueStorage()._paymentTime = nil}

  public var startedTime: Utils_Timestamp {
    get {return _storage._startedTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._startedTime = newValue}
  }
  /// Returns true if `startedTime` has been explicitly set.
  public var hasStartedTime: Bool {return _storage._startedTime != nil}
  /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

  public var completedTime: Utils_Timestamp {
    get {return _storage._completedTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._completedTime = newValue}
  }
  /// Returns true if `completedTime` has been explicitly set.
  public var hasCompletedTime: Bool {return _storage._completedTime != nil}
  /// Clears the value of `completedTime`. Subsequent reads from it will return its default value.
  public mutating func clearCompletedTime() {_uniqueStorage()._completedTime = nil}

  /// The service that was purchased.
  public var service: Products_Service {
    get {return _storage._service ?? Products_Service()}
    set {_uniqueStorage()._service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  public var hasService: Bool {return _storage._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  public mutating func clearService() {_uniqueStorage()._service = nil}

  /// Which salon the purchase was at.
  public var salonInfo: Server_SalonInfo {
    get {return _storage._salonInfo ?? Server_SalonInfo()}
    set {_uniqueStorage()._salonInfo = newValue}
  }
  /// Returns true if `salonInfo` has been explicitly set.
  public var hasSalonInfo: Bool {return _storage._salonInfo != nil}
  /// Clears the value of `salonInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSalonInfo() {_uniqueStorage()._salonInfo = nil}

  public var paymentMethod: Payments_PaymentMethod {
    get {return _storage._paymentMethod}
    set {_uniqueStorage()._paymentMethod = newValue}
  }

  /// The name of the customer. Might be "Name 1" or "Name 2" if the customer purchased multiple haircuts at the same time.
  public var customerName: String {
    get {return _storage._customerName}
    set {_uniqueStorage()._customerName = newValue}
  }

  public var queueURL: String {
    get {return _storage._queueURL}
    set {_uniqueStorage()._queueURL = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ProductTransaction describes a purchased product.
public struct Server_ActiveProductTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batchID: String = String()

  /// Which salon the purchase was at.
  public var salonInfo: Server_SalonInfo {
    get {return _salonInfo ?? Server_SalonInfo()}
    set {_salonInfo = newValue}
  }
  /// Returns true if `salonInfo` has been explicitly set.
  public var hasSalonInfo: Bool {return self._salonInfo != nil}
  /// Clears the value of `salonInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSalonInfo() {self._salonInfo = nil}

  public var paymentMethod: Payments_PaymentMethod = .invalid

  public var lineItems: [Products_ActiveLineItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _salonInfo: Server_SalonInfo? = nil
}

/// ServiceTransaction describes a purchased service.
public struct Server_HistoricalServiceTransaction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Service Transaction-ID: Used to get Waiting-status.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var batchID: String {
    get {return _storage._batchID}
    set {_uniqueStorage()._batchID = newValue}
  }

  public var registeredTime: Utils_Timestamp {
    get {return _storage._registeredTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._registeredTime = newValue}
  }
  /// Returns true if `registeredTime` has been explicitly set.
  public var hasRegisteredTime: Bool {return _storage._registeredTime != nil}
  /// Clears the value of `registeredTime`. Subsequent reads from it will return its default value.
  public mutating func clearRegisteredTime() {_uniqueStorage()._registeredTime = nil}

  public var paymentTime: Utils_Timestamp {
    get {return _storage._paymentTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._paymentTime = newValue}
  }
  /// Returns true if `paymentTime` has been explicitly set.
  public var hasPaymentTime: Bool {return _storage._paymentTime != nil}
  /// Clears the value of `paymentTime`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentTime() {_uniqueStorage()._paymentTime = nil}

  public var startedTime: Utils_Timestamp {
    get {return _storage._startedTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._startedTime = newValue}
  }
  /// Returns true if `startedTime` has been explicitly set.
  public var hasStartedTime: Bool {return _storage._startedTime != nil}
  /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

  public var completedTime: Utils_Timestamp {
    get {return _storage._completedTime ?? Utils_Timestamp()}
    set {_uniqueStorage()._completedTime = newValue}
  }
  /// Returns true if `completedTime` has been explicitly set.
  public var hasCompletedTime: Bool {return _storage._completedTime != nil}
  /// Clears the value of `completedTime`. Subsequent reads from it will return its default value.
  public mutating func clearCompletedTime() {_uniqueStorage()._completedTime = nil}

  /// The service that was purchased.
  public var service: Products_Service {
    get {return _storage._service ?? Products_Service()}
    set {_uniqueStorage()._service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  public var hasService: Bool {return _storage._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  public mutating func clearService() {_uniqueStorage()._service = nil}

  /// Which salon the purchase was at.
  public var salonInfo: Server_SalonInfo {
    get {return _storage._salonInfo ?? Server_SalonInfo()}
    set {_uniqueStorage()._salonInfo = newValue}
  }
  /// Returns true if `salonInfo` has been explicitly set.
  public var hasSalonInfo: Bool {return _storage._salonInfo != nil}
  /// Clears the value of `salonInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSalonInfo() {_uniqueStorage()._salonInfo = nil}

  /// The name of the customer. Might be "Name 1" or "Name 2" if the customer purchased multiple haircuts at the same time.
  public var customerName: String {
    get {return _storage._customerName}
    set {_uniqueStorage()._customerName = newValue}
  }

  public var queueURL: String {
    get {return _storage._queueURL}
    set {_uniqueStorage()._queueURL = newValue}
  }

  public var paymentMethod: Payments_PaymentMethod {
    get {return _storage._paymentMethod}
    set {_uniqueStorage()._paymentMethod = newValue}
  }

  public var ratingURL: String {
    get {return _storage._ratingURL}
    set {_uniqueStorage()._ratingURL = newValue}
  }

  public var rating: Int32 {
    get {return _storage._rating}
    set {_uniqueStorage()._rating = newValue}
  }

  public var ratingAvailable: Bool {
    get {return _storage._ratingAvailable}
    set {_uniqueStorage()._ratingAvailable = newValue}
  }

  public var state: Server_HistoricalTransactionState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  public var isRefunded: Bool {
    get {return _storage._isRefunded}
    set {_uniqueStorage()._isRefunded = newValue}
  }

  public var receiptURL: String {
    get {return _storage._receiptURL}
    set {_uniqueStorage()._receiptURL = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ProductTransaction describes a purchased product.
public struct Server_HistoricalProductTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batchID: String = String()

  /// Which salon the purchase was at.
  public var salonInfo: Server_SalonInfo {
    get {return _salonInfo ?? Server_SalonInfo()}
    set {_salonInfo = newValue}
  }
  /// Returns true if `salonInfo` has been explicitly set.
  public var hasSalonInfo: Bool {return self._salonInfo != nil}
  /// Clears the value of `salonInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSalonInfo() {self._salonInfo = nil}

  public var paymentMethod: Payments_PaymentMethod = .invalid

  public var receiptURL: String = String()

  public var lineItems: [Products_HistoricalLineItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _salonInfo: Server_SalonInfo? = nil
}

/// SalonInfo represents essential info about a salon.
public struct Server_SalonInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var location: Server_Location {
    get {return _location ?? Server_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _location: Server_Location? = nil
}

/// ReadableWaitingTime describes a waiting-time in a readable format.
public struct Server_ReadableWaitingTime: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Short format, e.g. "<5m".
  public var shortFormat: String = String()

  /// Long format, e.g. "Less than 5 min".
  public var longFormat: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AvailablePaymentProviders contains all available payment solutions for any given salon.
public struct Server_AvailablePaymentProviders: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var voucher: Bool = false

  public var stripe: Bool = false

  public var vipps: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_HistoricalTransactionState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HISTORICAL_TRANSACTION_STATE_INVALID"),
    1: .same(proto: "HISTORICAL_TRANSACTION_STATE_COMPLETED"),
    2: .same(proto: "HISTORICAL_TRANSACTION_STATE_CANCELLED"),
    3: .same(proto: "HISTORICAL_TRANSACTION_STATE_NOSHOW"),
    4: .same(proto: "HISTORICAL_TRANSACTION_STATE_ERROR"),
  ]
}

extension Server_BookingStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOOKING_STATUS_INVALID"),
    1: .same(proto: "BOOKING_STATUS_UNKNOWN"),
    2: .same(proto: "BOOKING_STATUS_REGISTERED"),
    3: .same(proto: "BOOKING_STATUS_STARTED"),
    4: .same(proto: "BOOKING_STATUS_STOPPED"),
    5: .same(proto: "BOOKING_STATUS_SERVING"),
    6: .same(proto: "BOOKING_STATUS_NOSHOW"),
  ]
}

extension Server_ServiceStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SERVICE_STATUS_INVALID"),
    2: .same(proto: "SERVICE_STATUS_ORDER_COMPLETE"),
    3: .same(proto: "SERVICE_STATUS_WAITING"),
    4: .same(proto: "SERVICE_STATUS_ALMOST_READY"),
    5: .same(proto: "SERVICE_STATUS_YOUR_TURN"),
    6: .same(proto: "SERVICE_STATUS_COMPLETED"),
  ]
}

extension Server_WaitingTimePrecision: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WAITING_TIME_PRECISION_INVALID"),
    1: .same(proto: "WAITING_TIME_PRECISION_UNKNOWN"),
    2: .same(proto: "WAITING_TIME_PRECISION_APPROXIMATE"),
    3: .same(proto: "WAITING_TIME_PRECISION_NONE"),
  ]
}

extension Server_AvailableHairdressersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AvailableHairdressersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "salon_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AvailableHairdressersRequest, rhs: Server_AvailableHairdressersRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.salonID != rhs.salonID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AvailableHairdressersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AvailableHairdressersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "anonymous_hairdressers"),
    2: .same(proto: "hairdressers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.anonymousHairdressers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.hairdressers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.anonymousHairdressers != 0 {
      try visitor.visitSingularInt32Field(value: self.anonymousHairdressers, fieldNumber: 1)
    }
    if !self.hairdressers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hairdressers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AvailableHairdressersResponse, rhs: Server_AvailableHairdressersResponse) -> Bool {
    if lhs.anonymousHairdressers != rhs.anonymousHairdressers {return false}
    if lhs.hairdressers != rhs.hairdressers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Hairdresser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hairdresser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "initials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.initials) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.initials.isEmpty {
      try visitor.visitSingularStringField(value: self.initials, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Hairdresser, rhs: Server_Hairdresser) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.initials != rhs.initials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetWaitingTimesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWaitingTimesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "empty"),
    2: .same(proto: "location"),
    3: .same(proto: "locales"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Utils_Empty?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .empty(v)
        }
      }()
      case 2: try {
        var v: Server_Location?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .location(v)
        }
      }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.locales) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mode {
    case .empty?: try {
      guard case .empty(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .location?: try {
      guard case .location(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.locales.isEmpty {
      try visitor.visitRepeatedStringField(value: self.locales, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetWaitingTimesRequest, rhs: Server_GetWaitingTimesRequest) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.locales != rhs.locales {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetWaitingTimesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWaitingTimesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "salon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._salon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._salon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetWaitingTimesResponse, rhs: Server_GetWaitingTimesResponse) -> Bool {
    if lhs._salon != rhs._salon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetSalonRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSalonRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "salon_id"),
    2: .same(proto: "locales"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.locales) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 1)
    }
    if !self.locales.isEmpty {
      try visitor.visitRepeatedStringField(value: self.locales, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetSalonRequest, rhs: Server_GetSalonRequest) -> Bool {
    if lhs.salonID != rhs.salonID {return false}
    if lhs.locales != rhs.locales {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetSalonResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSalonResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "salon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._salon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._salon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetSalonResponse, rhs: Server_GetSalonResponse) -> Bool {
    if lhs._salon != rhs._salon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_BookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "salon_id"),
    3: .same(proto: "products"),
    4: .same(proto: "payment"),
    17: .standard(proto: "allow_async"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.products) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payment) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.allowAsync) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 2)
    }
    if !self.products.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.products, fieldNumber: 3)
    }
    try { if let v = self._payment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.allowAsync != false {
      try visitor.visitSingularBoolField(value: self.allowAsync, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_BookRequest, rhs: Server_BookRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.salonID != rhs.salonID {return false}
    if lhs.products != rhs.products {return false}
    if lhs._payment != rhs._payment {return false}
    if lhs.allowAsync != rhs.allowAsync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_BookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment"),
    2: .same(proto: "booking"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._booking) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._booking {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_BookResponse, rhs: Server_BookResponse) -> Bool {
    if lhs._payment != rhs._payment {return false}
    if lhs._booking != rhs._booking {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PurchaseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PurchaseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "salon_id"),
    3: .same(proto: "services"),
    4: .same(proto: "products"),
    5: .same(proto: "payment"),
    6: .standard(proto: "aware_of_campaigns"),
    7: .standard(proto: "idempotency_key"),
  ]

  fileprivate class _StorageClass {
    var _auth: Auth_Authentication? = nil
    var _salonID: String = String()
    var _services: [Products_ServiceRequest] = []
    var _products: [Products_ProductRequest] = []
    var _payment: Payments_PaymentRequest? = nil
    var _awareOfCampaigns: Bool = false
    var _idempotencyKey: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _auth = source._auth
      _salonID = source._salonID
      _services = source._services
      _products = source._products
      _payment = source._payment
      _awareOfCampaigns = source._awareOfCampaigns
      _idempotencyKey = source._idempotencyKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._auth) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._salonID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._services) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._products) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._payment) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._awareOfCampaigns) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._idempotencyKey) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._auth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._salonID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._salonID, fieldNumber: 2)
      }
      if !_storage._services.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._services, fieldNumber: 3)
      }
      if !_storage._products.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._products, fieldNumber: 4)
      }
      try { if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._awareOfCampaigns != false {
        try visitor.visitSingularBoolField(value: _storage._awareOfCampaigns, fieldNumber: 6)
      }
      if !_storage._idempotencyKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idempotencyKey, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PurchaseRequest, rhs: Server_PurchaseRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._auth != rhs_storage._auth {return false}
        if _storage._salonID != rhs_storage._salonID {return false}
        if _storage._services != rhs_storage._services {return false}
        if _storage._products != rhs_storage._products {return false}
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._awareOfCampaigns != rhs_storage._awareOfCampaigns {return false}
        if _storage._idempotencyKey != rhs_storage._idempotencyKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PurchaseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PurchaseResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment"),
    2: .same(proto: "bookings"),
    3: .standard(proto: "idempotency_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payment) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bookings) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.idempotencyKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.bookings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bookings, fieldNumber: 2)
    }
    if !self.idempotencyKey.isEmpty {
      try visitor.visitSingularStringField(value: self.idempotencyKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PurchaseResponse, rhs: Server_PurchaseResponse) -> Bool {
    if lhs._payment != rhs._payment {return false}
    if lhs.bookings != rhs.bookings {return false}
    if lhs.idempotencyKey != rhs.idempotencyKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetAvailablePaymentProvidersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAvailablePaymentProvidersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetAvailablePaymentProvidersRequest, rhs: Server_GetAvailablePaymentProvidersRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetAvailablePaymentProvidersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAvailablePaymentProvidersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "providers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._providers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._providers {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetAvailablePaymentProvidersResponse, rhs: Server_GetAvailablePaymentProvidersResponse) -> Bool {
    if lhs._providers != rhs._providers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "salon_id"),
    3: .same(proto: "services"),
    4: .same(proto: "products"),
    5: .same(proto: "voucher"),
    6: .same(proto: "vouchers"),
    7: .same(proto: "coupons"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.products) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._voucher) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.vouchers) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.coupons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 2)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 3)
    }
    if !self.products.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.products, fieldNumber: 4)
    }
    try { if let v = self._voucher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.vouchers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vouchers, fieldNumber: 6)
    }
    if !self.coupons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coupons, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetPriceRequest, rhs: Server_GetPriceRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.salonID != rhs.salonID {return false}
    if lhs.services != rhs.services {return false}
    if lhs.products != rhs.products {return false}
    if lhs._voucher != rhs._voucher {return false}
    if lhs.vouchers != rhs.vouchers {return false}
    if lhs.coupons != rhs.coupons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "coupons"),
    3: .same(proto: "vouchers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.coupons) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.vouchers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.coupons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coupons, fieldNumber: 2)
    }
    if !self.vouchers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vouchers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetPriceResponse, rhs: Server_GetPriceResponse) -> Bool {
    if lhs._price != rhs._price {return false}
    if lhs.coupons != rhs.coupons {return false}
    if lhs.vouchers != rhs.vouchers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetCampaignsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "salon_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetCampaignsRequest, rhs: Server_GetCampaignsRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.salonID != rhs.salonID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetCampaignsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_campaign"),
    2: .standard(proto: "campaign_text"),
    3: .standard(proto: "campaign_dialog_title"),
    4: .standard(proto: "campaign_dialog_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.activeCampaign) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.campaignText) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.campaignDialogTitle) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.campaignDialogMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activeCampaign != false {
      try visitor.visitSingularBoolField(value: self.activeCampaign, fieldNumber: 1)
    }
    if !self.campaignText.isEmpty {
      try visitor.visitSingularStringField(value: self.campaignText, fieldNumber: 2)
    }
    if !self.campaignDialogTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.campaignDialogTitle, fieldNumber: 3)
    }
    if !self.campaignDialogMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.campaignDialogMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetCampaignsResponse, rhs: Server_GetCampaignsResponse) -> Bool {
    if lhs.activeCampaign != rhs.activeCampaign {return false}
    if lhs.campaignText != rhs.campaignText {return false}
    if lhs.campaignDialogTitle != rhs.campaignDialogTitle {return false}
    if lhs.campaignDialogMessage != rhs.campaignDialogMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServicesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "salon_id"),
    2: .same(proto: "locales"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.locales) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 1)
    }
    if !self.locales.isEmpty {
      try visitor.visitRepeatedStringField(value: self.locales, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetServicesRequest, rhs: Server_GetServicesRequest) -> Bool {
    if lhs.salonID != rhs.salonID {return false}
    if lhs.locales != rhs.locales {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetServicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServicesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
    2: .standard(proto: "available_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._service) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.availableCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._service {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.availableCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.availableCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetServicesResponse, rhs: Server_GetServicesResponse) -> Bool {
    if lhs._service != rhs._service {return false}
    if lhs.availableCount != rhs.availableCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetProductsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProductsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "salon_id"),
    2: .same(proto: "locales"),
    3: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.locales) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 1)
    }
    if !self.locales.isEmpty {
      try visitor.visitRepeatedStringField(value: self.locales, fieldNumber: 2)
    }
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetProductsRequest, rhs: Server_GetProductsRequest) -> Bool {
    if lhs.salonID != rhs.salonID {return false}
    if lhs.locales != rhs.locales {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetProductsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProductsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "product"),
    2: .standard(proto: "stock_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._product) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stockCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._product {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.stockCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.stockCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetProductsResponse, rhs: Server_GetProductsResponse) -> Bool {
    if lhs._product != rhs._product {return false}
    if lhs.stockCount != rhs.stockCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetWaitingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWaitingStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "transaction_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetWaitingStatusRequest, rhs: Server_GetWaitingStatusRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetWaitingStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWaitingStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "booking"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._booking) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._booking {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetWaitingStatusResponse, rhs: Server_GetWaitingStatusResponse) -> Bool {
    if lhs._booking != rhs._booking {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ListTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTransactionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "include_active"),
    3: .standard(proto: "include_historic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeActive) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeHistoric) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.includeActive != false {
      try visitor.visitSingularBoolField(value: self.includeActive, fieldNumber: 2)
    }
    if self.includeHistoric != false {
      try visitor.visitSingularBoolField(value: self.includeHistoric, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ListTransactionsRequest, rhs: Server_ListTransactionsRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.includeActive != rhs.includeActive {return false}
    if lhs.includeHistoric != rhs.includeHistoric {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ListTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTransactionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_services"),
    2: .standard(proto: "active_products"),
    3: .standard(proto: "historic_services"),
    4: .standard(proto: "historic_products"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.activeServices) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.activeProducts) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.historicServices) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.historicProducts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activeServices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activeServices, fieldNumber: 1)
    }
    if !self.activeProducts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activeProducts, fieldNumber: 2)
    }
    if !self.historicServices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.historicServices, fieldNumber: 3)
    }
    if !self.historicProducts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.historicProducts, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ListTransactionsResponse, rhs: Server_ListTransactionsResponse) -> Bool {
    if lhs.activeServices != rhs.activeServices {return false}
    if lhs.activeProducts != rhs.activeProducts {return false}
    if lhs.historicServices != rhs.historicServices {return false}
    if lhs.historicProducts != rhs.historicProducts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CanRedeemVoucherRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanRedeemVoucherRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "voucher"),
    3: .standard(proto: "salon_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._voucher) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._voucher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CanRedeemVoucherRequest, rhs: Server_CanRedeemVoucherRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._voucher != rhs._voucher {return false}
    if lhs.salonID != rhs.salonID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CanRedeemVoucherResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanRedeemVoucherResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_redeem"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canRedeem) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canRedeem != false {
      try visitor.visitSingularBoolField(value: self.canRedeem, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CanRedeemVoucherResponse, rhs: Server_CanRedeemVoucherResponse) -> Bool {
    if lhs.canRedeem != rhs.canRedeem {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CreateVoucherRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateVoucherRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CreateVoucherRequest, rhs: Server_CreateVoucherRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CreateVoucherResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateVoucherResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "voucher"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._voucher) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._voucher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CreateVoucherResponse, rhs: Server_CreateVoucherResponse) -> Bool {
    if lhs._voucher != rhs._voucher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetReferralStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetReferralStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetReferralStatusRequest, rhs: Server_GetReferralStatusRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetReferralStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetReferralStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_referral_count"),
    2: .standard(proto: "target_referral_count"),
    3: .same(proto: "voucher"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.currentReferralCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.targetReferralCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.voucher) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.currentReferralCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.currentReferralCount, fieldNumber: 1)
    }
    if self.targetReferralCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetReferralCount, fieldNumber: 2)
    }
    if !self.voucher.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.voucher, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetReferralStatusResponse, rhs: Server_GetReferralStatusResponse) -> Bool {
    if lhs.currentReferralCount != rhs.currentReferralCount {return false}
    if lhs.targetReferralCount != rhs.targetReferralCount {return false}
    if lhs.voucher != rhs.voucher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CancelServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "transaction_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CancelServiceRequest, rhs: Server_CancelServiceRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CancelServiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelServiceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CancelServiceResponse, rhs: Server_CancelServiceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RemoteLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteLogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "auth"),
    1: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.event) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.event.isEmpty {
      try visitor.visitSingularStringField(value: self.event, fieldNumber: 1)
    }
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RemoteLogRequest, rhs: Server_RemoteLogRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RemoteLogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteLogResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RemoteLogResponse, rhs: Server_RemoteLogResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_TimeoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeoutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.seconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TimeoutRequest, rhs: Server_TimeoutRequest) -> Bool {
    if lhs.seconds != rhs.seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_TimeoutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeoutResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TimeoutResponse, rhs: Server_TimeoutResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ListActiveTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActiveTransactionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ListActiveTransactionsRequest, rhs: Server_ListActiveTransactionsRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ListActiveTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActiveTransactionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_transactions"),
    2: .standard(proto: "product_transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serviceTransactions) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.productTransactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceTransactions, fieldNumber: 1)
    }
    if !self.productTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.productTransactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ListActiveTransactionsResponse, rhs: Server_ListActiveTransactionsResponse) -> Bool {
    if lhs.serviceTransactions != rhs.serviceTransactions {return false}
    if lhs.productTransactions != rhs.productTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ListHistoricalTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListHistoricalTransactionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "since"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._since) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._since {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ListHistoricalTransactionsRequest, rhs: Server_ListHistoricalTransactionsRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._since != rhs._since {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ListHistoricalTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListHistoricalTransactionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_transactions"),
    2: .standard(proto: "product_transactions"),
    3: .standard(proto: "days_since_last_haircut"),
    4: .standard(proto: "days_since_last_haircut_picture_url"),
    5: .standard(proto: "days_since_last_haircut_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serviceTransactions) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.productTransactions) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.daysSinceLastHaircut) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.daysSinceLastHaircutPictureURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.daysSinceLastHaircutText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceTransactions, fieldNumber: 1)
    }
    if !self.productTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.productTransactions, fieldNumber: 2)
    }
    if self.daysSinceLastHaircut != 0 {
      try visitor.visitSingularInt32Field(value: self.daysSinceLastHaircut, fieldNumber: 3)
    }
    if !self.daysSinceLastHaircutPictureURL.isEmpty {
      try visitor.visitSingularStringField(value: self.daysSinceLastHaircutPictureURL, fieldNumber: 4)
    }
    if !self.daysSinceLastHaircutText.isEmpty {
      try visitor.visitSingularStringField(value: self.daysSinceLastHaircutText, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ListHistoricalTransactionsResponse, rhs: Server_ListHistoricalTransactionsResponse) -> Bool {
    if lhs.serviceTransactions != rhs.serviceTransactions {return false}
    if lhs.productTransactions != rhs.productTransactions {return false}
    if lhs.daysSinceLastHaircut != rhs.daysSinceLastHaircut {return false}
    if lhs.daysSinceLastHaircutPictureURL != rhs.daysSinceLastHaircutPictureURL {return false}
    if lhs.daysSinceLastHaircutText != rhs.daysSinceLastHaircutText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_BookingDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BookingDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "waiting_time"),
    3: .standard(proto: "transaction_id"),
    4: .same(proto: "status"),
    5: .standard(proto: "position_in_queue"),
    6: .standard(proto: "queue_url"),
    7: .standard(proto: "service_status"),
    8: .standard(proto: "estimated_wait"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.waitingTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.positionInQueue) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.queueURL) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.serviceStatus) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._estimatedWait) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if self.waitingTime != 0 {
      try visitor.visitSingularInt32Field(value: self.waitingTime, fieldNumber: 2)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 3)
    }
    if self.status != .invalid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if self.positionInQueue != 0 {
      try visitor.visitSingularInt32Field(value: self.positionInQueue, fieldNumber: 5)
    }
    if !self.queueURL.isEmpty {
      try visitor.visitSingularStringField(value: self.queueURL, fieldNumber: 6)
    }
    if self.serviceStatus != .invalid {
      try visitor.visitSingularEnumField(value: self.serviceStatus, fieldNumber: 7)
    }
    try { if let v = self._estimatedWait {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_BookingDetails, rhs: Server_BookingDetails) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.waitingTime != rhs.waitingTime {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.positionInQueue != rhs.positionInQueue {return false}
    if lhs.queueURL != rhs.queueURL {return false}
    if lhs.serviceStatus != rhs.serviceStatus {return false}
    if lhs._estimatedWait != rhs._estimatedWait {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_OpeningTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpeningTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.`open`) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.from) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`open` != false {
      try visitor.visitSingularBoolField(value: self.`open`, fieldNumber: 1)
    }
    if self.from != 0 {
      try visitor.visitSingularUInt32Field(value: self.from, fieldNumber: 2)
    }
    if self.to != 0 {
      try visitor.visitSingularUInt32Field(value: self.to, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_OpeningTime, rhs: Server_OpeningTime) -> Bool {
    if lhs.`open` != rhs.`open` {return false}
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Timetable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Timetable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mon"),
    2: .same(proto: "tue"),
    3: .same(proto: "wed"),
    4: .same(proto: "thu"),
    5: .same(proto: "fri"),
    6: .same(proto: "sat"),
    7: .same(proto: "sun"),
  ]

  fileprivate class _StorageClass {
    var _mon: Server_OpeningTime? = nil
    var _tue: Server_OpeningTime? = nil
    var _wed: Server_OpeningTime? = nil
    var _thu: Server_OpeningTime? = nil
    var _fri: Server_OpeningTime? = nil
    var _sat: Server_OpeningTime? = nil
    var _sun: Server_OpeningTime? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _mon = source._mon
      _tue = source._tue
      _wed = source._wed
      _thu = source._thu
      _fri = source._fri
      _sat = source._sat
      _sun = source._sun
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._mon) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._wed) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._thu) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._fri) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sat) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._sun) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._mon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._wed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._thu {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._fri {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._sun {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Timetable, rhs: Server_Timetable) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mon != rhs_storage._mon {return false}
        if _storage._tue != rhs_storage._tue {return false}
        if _storage._wed != rhs_storage._wed {return false}
        if _storage._thu != rhs_storage._thu {return false}
        if _storage._fri != rhs_storage._fri {return false}
        if _storage._sat != rhs_storage._sat {return false}
        if _storage._sun != rhs_storage._sun {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Salon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Salon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "waiting_time"),
    3: .standard(proto: "in_queue"),
    4: .same(proto: "name"),
    5: .same(proto: "city"),
    6: .same(proto: "country"),
    7: .same(proto: "address"),
    8: .standard(proto: "post_number"),
    9: .same(proto: "post"),
    10: .same(proto: "phone"),
    11: .same(proto: "email"),
    12: .same(proto: "times"),
    13: .same(proto: "open"),
    14: .same(proto: "location"),
    15: .standard(proto: "haircut_price"),
    16: .standard(proto: "relative_location"),
    17: .same(proto: "currency"),
    18: .standard(proto: "default_phone_prefix"),
    19: .standard(proto: "estimated_wait"),
    20: .same(proto: "precision"),
    21: .same(proto: "providers"),
    22: .standard(proto: "is_referring_enabled"),
    23: .standard(proto: "available_hairdressers"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _waitingTime: Int32 = 0
    var _inQueue: UInt32 = 0
    var _name: String = String()
    var _city: String = String()
    var _country: String = String()
    var _address: String = String()
    var _postNumber: String = String()
    var _post: String = String()
    var _phone: String = String()
    var _email: String = String()
    var _times: Server_Timetable? = nil
    var _open: Bool = false
    var _location: Server_Location? = nil
    var _haircutPrice: Money_Price? = nil
    var _relativeLocation: String = String()
    var _currency: Money_Currency? = nil
    var _defaultPhonePrefix: String = String()
    var _estimatedWait: Server_ReadableWaitingTime? = nil
    var _precision: Server_WaitingTimePrecision = .invalid
    var _providers: Server_AvailablePaymentProviders? = nil
    var _isReferringEnabled: Bool = false
    var _availableHairdressers: Server_AvailableHairdressersResponse? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _waitingTime = source._waitingTime
      _inQueue = source._inQueue
      _name = source._name
      _city = source._city
      _country = source._country
      _address = source._address
      _postNumber = source._postNumber
      _post = source._post
      _phone = source._phone
      _email = source._email
      _times = source._times
      _open = source._open
      _location = source._location
      _haircutPrice = source._haircutPrice
      _relativeLocation = source._relativeLocation
      _currency = source._currency
      _defaultPhonePrefix = source._defaultPhonePrefix
      _estimatedWait = source._estimatedWait
      _precision = source._precision
      _providers = source._providers
      _isReferringEnabled = source._isReferringEnabled
      _availableHairdressers = source._availableHairdressers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._waitingTime) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._inQueue) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._city) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._country) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._postNumber) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._post) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._phone) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._times) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._open) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._haircutPrice) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._relativeLocation) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._currency) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._defaultPhonePrefix) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._estimatedWait) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._precision) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._providers) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._isReferringEnabled) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._availableHairdressers) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._waitingTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._waitingTime, fieldNumber: 2)
      }
      if _storage._inQueue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._inQueue, fieldNumber: 3)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 4)
      }
      if !_storage._city.isEmpty {
        try visitor.visitSingularStringField(value: _storage._city, fieldNumber: 5)
      }
      if !_storage._country.isEmpty {
        try visitor.visitSingularStringField(value: _storage._country, fieldNumber: 6)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 7)
      }
      if !_storage._postNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._postNumber, fieldNumber: 8)
      }
      if !_storage._post.isEmpty {
        try visitor.visitSingularStringField(value: _storage._post, fieldNumber: 9)
      }
      if !_storage._phone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._phone, fieldNumber: 10)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 11)
      }
      try { if let v = _storage._times {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._open != false {
        try visitor.visitSingularBoolField(value: _storage._open, fieldNumber: 13)
      }
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._haircutPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._relativeLocation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relativeLocation, fieldNumber: 16)
      }
      try { if let v = _storage._currency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._defaultPhonePrefix.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultPhonePrefix, fieldNumber: 18)
      }
      try { if let v = _storage._estimatedWait {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if _storage._precision != .invalid {
        try visitor.visitSingularEnumField(value: _storage._precision, fieldNumber: 20)
      }
      try { if let v = _storage._providers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if _storage._isReferringEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isReferringEnabled, fieldNumber: 22)
      }
      try { if let v = _storage._availableHairdressers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Salon, rhs: Server_Salon) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._waitingTime != rhs_storage._waitingTime {return false}
        if _storage._inQueue != rhs_storage._inQueue {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._city != rhs_storage._city {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._postNumber != rhs_storage._postNumber {return false}
        if _storage._post != rhs_storage._post {return false}
        if _storage._phone != rhs_storage._phone {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._times != rhs_storage._times {return false}
        if _storage._open != rhs_storage._open {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._haircutPrice != rhs_storage._haircutPrice {return false}
        if _storage._relativeLocation != rhs_storage._relativeLocation {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._defaultPhonePrefix != rhs_storage._defaultPhonePrefix {return false}
        if _storage._estimatedWait != rhs_storage._estimatedWait {return false}
        if _storage._precision != rhs_storage._precision {return false}
        if _storage._providers != rhs_storage._providers {return false}
        if _storage._isReferringEnabled != rhs_storage._isReferringEnabled {return false}
        if _storage._availableHairdressers != rhs_storage._availableHairdressers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lng"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lng) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lng.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lng, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Location, rhs: Server_Location) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lng != rhs.lng {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ServiceTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "registered_time"),
    3: .standard(proto: "payment_time"),
    4: .standard(proto: "started_time"),
    5: .standard(proto: "completed_time"),
    6: .same(proto: "service"),
    7: .standard(proto: "salon_id"),
    8: .standard(proto: "customer_name"),
    9: .standard(proto: "queue_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._registeredTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startedTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._completedTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._service) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.salonID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.customerName) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.queueURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._registeredTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._paymentTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._completedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._service {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.salonID.isEmpty {
      try visitor.visitSingularStringField(value: self.salonID, fieldNumber: 7)
    }
    if !self.customerName.isEmpty {
      try visitor.visitSingularStringField(value: self.customerName, fieldNumber: 8)
    }
    if !self.queueURL.isEmpty {
      try visitor.visitSingularStringField(value: self.queueURL, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ServiceTransaction, rhs: Server_ServiceTransaction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._registeredTime != rhs._registeredTime {return false}
    if lhs._paymentTime != rhs._paymentTime {return false}
    if lhs._startedTime != rhs._startedTime {return false}
    if lhs._completedTime != rhs._completedTime {return false}
    if lhs._service != rhs._service {return false}
    if lhs.salonID != rhs.salonID {return false}
    if lhs.customerName != rhs.customerName {return false}
    if lhs.queueURL != rhs.queueURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ProductTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProductTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "registered_time"),
    3: .standard(proto: "payment_time"),
    4: .standard(proto: "started_time"),
    5: .standard(proto: "completed_time"),
    6: .same(proto: "product"),
    7: .standard(proto: "salon_id"),
    8: .same(proto: "quantity"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _registeredTime: Utils_Timestamp? = nil
    var _paymentTime: Utils_Timestamp? = nil
    var _startedTime: Utils_Timestamp? = nil
    var _completedTime: Utils_Timestamp? = nil
    var _product: Products_Product? = nil
    var _salonID: String = String()
    var _quantity: UInt32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _registeredTime = source._registeredTime
      _paymentTime = source._paymentTime
      _startedTime = source._startedTime
      _completedTime = source._completedTime
      _product = source._product
      _salonID = source._salonID
      _quantity = source._quantity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._registeredTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._paymentTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._completedTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._product) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._salonID) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._quantity) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._registeredTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._paymentTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._completedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._product {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._salonID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._salonID, fieldNumber: 7)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._quantity, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ProductTransaction, rhs: Server_ProductTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._registeredTime != rhs_storage._registeredTime {return false}
        if _storage._paymentTime != rhs_storage._paymentTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._completedTime != rhs_storage._completedTime {return false}
        if _storage._product != rhs_storage._product {return false}
        if _storage._salonID != rhs_storage._salonID {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ActiveServiceTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveServiceTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "batch_id"),
    3: .standard(proto: "registered_time"),
    4: .standard(proto: "payment_time"),
    5: .standard(proto: "started_time"),
    6: .standard(proto: "completed_time"),
    7: .same(proto: "service"),
    8: .standard(proto: "salon_info"),
    9: .standard(proto: "payment_method"),
    10: .standard(proto: "customer_name"),
    11: .standard(proto: "queue_url"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _batchID: String = String()
    var _registeredTime: Utils_Timestamp? = nil
    var _paymentTime: Utils_Timestamp? = nil
    var _startedTime: Utils_Timestamp? = nil
    var _completedTime: Utils_Timestamp? = nil
    var _service: Products_Service? = nil
    var _salonInfo: Server_SalonInfo? = nil
    var _paymentMethod: Payments_PaymentMethod = .invalid
    var _customerName: String = String()
    var _queueURL: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _batchID = source._batchID
      _registeredTime = source._registeredTime
      _paymentTime = source._paymentTime
      _startedTime = source._startedTime
      _completedTime = source._completedTime
      _service = source._service
      _salonInfo = source._salonInfo
      _paymentMethod = source._paymentMethod
      _customerName = source._customerName
      _queueURL = source._queueURL
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._batchID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._registeredTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._paymentTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._completedTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._service) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._salonInfo) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._paymentMethod) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._customerName) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._queueURL) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._batchID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._batchID, fieldNumber: 2)
      }
      try { if let v = _storage._registeredTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._paymentTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._completedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._service {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._salonInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._paymentMethod != .invalid {
        try visitor.visitSingularEnumField(value: _storage._paymentMethod, fieldNumber: 9)
      }
      if !_storage._customerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customerName, fieldNumber: 10)
      }
      if !_storage._queueURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._queueURL, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ActiveServiceTransaction, rhs: Server_ActiveServiceTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._batchID != rhs_storage._batchID {return false}
        if _storage._registeredTime != rhs_storage._registeredTime {return false}
        if _storage._paymentTime != rhs_storage._paymentTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._completedTime != rhs_storage._completedTime {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._salonInfo != rhs_storage._salonInfo {return false}
        if _storage._paymentMethod != rhs_storage._paymentMethod {return false}
        if _storage._customerName != rhs_storage._customerName {return false}
        if _storage._queueURL != rhs_storage._queueURL {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ActiveProductTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveProductTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_id"),
    2: .standard(proto: "salon_info"),
    3: .standard(proto: "payment_method"),
    4: .standard(proto: "line_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._salonInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.paymentMethod) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.lineItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 1)
    }
    try { if let v = self._salonInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.paymentMethod != .invalid {
      try visitor.visitSingularEnumField(value: self.paymentMethod, fieldNumber: 3)
    }
    if !self.lineItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lineItems, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ActiveProductTransaction, rhs: Server_ActiveProductTransaction) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs._salonInfo != rhs._salonInfo {return false}
    if lhs.paymentMethod != rhs.paymentMethod {return false}
    if lhs.lineItems != rhs.lineItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HistoricalServiceTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoricalServiceTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "batch_id"),
    3: .standard(proto: "registered_time"),
    4: .standard(proto: "payment_time"),
    5: .standard(proto: "started_time"),
    6: .standard(proto: "completed_time"),
    7: .same(proto: "service"),
    8: .standard(proto: "salon_info"),
    9: .standard(proto: "customer_name"),
    10: .standard(proto: "queue_url"),
    11: .standard(proto: "payment_method"),
    12: .standard(proto: "rating_url"),
    13: .same(proto: "rating"),
    14: .standard(proto: "rating_available"),
    15: .same(proto: "state"),
    16: .standard(proto: "is_refunded"),
    17: .standard(proto: "receipt_url"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _batchID: String = String()
    var _registeredTime: Utils_Timestamp? = nil
    var _paymentTime: Utils_Timestamp? = nil
    var _startedTime: Utils_Timestamp? = nil
    var _completedTime: Utils_Timestamp? = nil
    var _service: Products_Service? = nil
    var _salonInfo: Server_SalonInfo? = nil
    var _customerName: String = String()
    var _queueURL: String = String()
    var _paymentMethod: Payments_PaymentMethod = .invalid
    var _ratingURL: String = String()
    var _rating: Int32 = 0
    var _ratingAvailable: Bool = false
    var _state: Server_HistoricalTransactionState = .invalid
    var _isRefunded: Bool = false
    var _receiptURL: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _batchID = source._batchID
      _registeredTime = source._registeredTime
      _paymentTime = source._paymentTime
      _startedTime = source._startedTime
      _completedTime = source._completedTime
      _service = source._service
      _salonInfo = source._salonInfo
      _customerName = source._customerName
      _queueURL = source._queueURL
      _paymentMethod = source._paymentMethod
      _ratingURL = source._ratingURL
      _rating = source._rating
      _ratingAvailable = source._ratingAvailable
      _state = source._state
      _isRefunded = source._isRefunded
      _receiptURL = source._receiptURL
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._batchID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._registeredTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._paymentTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._completedTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._service) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._salonInfo) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._customerName) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._queueURL) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._paymentMethod) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._ratingURL) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._rating) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._ratingAvailable) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isRefunded) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._receiptURL) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._batchID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._batchID, fieldNumber: 2)
      }
      try { if let v = _storage._registeredTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._paymentTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._completedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._service {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._salonInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._customerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customerName, fieldNumber: 9)
      }
      if !_storage._queueURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._queueURL, fieldNumber: 10)
      }
      if _storage._paymentMethod != .invalid {
        try visitor.visitSingularEnumField(value: _storage._paymentMethod, fieldNumber: 11)
      }
      if !_storage._ratingURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ratingURL, fieldNumber: 12)
      }
      if _storage._rating != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rating, fieldNumber: 13)
      }
      if _storage._ratingAvailable != false {
        try visitor.visitSingularBoolField(value: _storage._ratingAvailable, fieldNumber: 14)
      }
      if _storage._state != .invalid {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 15)
      }
      if _storage._isRefunded != false {
        try visitor.visitSingularBoolField(value: _storage._isRefunded, fieldNumber: 16)
      }
      if !_storage._receiptURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiptURL, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HistoricalServiceTransaction, rhs: Server_HistoricalServiceTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._batchID != rhs_storage._batchID {return false}
        if _storage._registeredTime != rhs_storage._registeredTime {return false}
        if _storage._paymentTime != rhs_storage._paymentTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._completedTime != rhs_storage._completedTime {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._salonInfo != rhs_storage._salonInfo {return false}
        if _storage._customerName != rhs_storage._customerName {return false}
        if _storage._queueURL != rhs_storage._queueURL {return false}
        if _storage._paymentMethod != rhs_storage._paymentMethod {return false}
        if _storage._ratingURL != rhs_storage._ratingURL {return false}
        if _storage._rating != rhs_storage._rating {return false}
        if _storage._ratingAvailable != rhs_storage._ratingAvailable {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._isRefunded != rhs_storage._isRefunded {return false}
        if _storage._receiptURL != rhs_storage._receiptURL {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HistoricalProductTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoricalProductTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_id"),
    2: .standard(proto: "salon_info"),
    3: .standard(proto: "payment_method"),
    4: .standard(proto: "receipt_url"),
    5: .standard(proto: "line_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._salonInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.paymentMethod) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.receiptURL) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.lineItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 1)
    }
    try { if let v = self._salonInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.paymentMethod != .invalid {
      try visitor.visitSingularEnumField(value: self.paymentMethod, fieldNumber: 3)
    }
    if !self.receiptURL.isEmpty {
      try visitor.visitSingularStringField(value: self.receiptURL, fieldNumber: 4)
    }
    if !self.lineItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lineItems, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HistoricalProductTransaction, rhs: Server_HistoricalProductTransaction) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs._salonInfo != rhs._salonInfo {return false}
    if lhs.paymentMethod != rhs.paymentMethod {return false}
    if lhs.receiptURL != rhs.receiptURL {return false}
    if lhs.lineItems != rhs.lineItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SalonInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SalonInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SalonInfo, rhs: Server_SalonInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._location != rhs._location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ReadableWaitingTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadableWaitingTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "short_format"),
    2: .standard(proto: "long_format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.shortFormat) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shortFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.shortFormat, fieldNumber: 1)
    }
    if !self.longFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.longFormat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ReadableWaitingTime, rhs: Server_ReadableWaitingTime) -> Bool {
    if lhs.shortFormat != rhs.shortFormat {return false}
    if lhs.longFormat != rhs.longFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AvailablePaymentProviders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AvailablePaymentProviders"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "voucher"),
    2: .same(proto: "stripe"),
    3: .same(proto: "vipps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.voucher) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.stripe) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.vipps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.voucher != false {
      try visitor.visitSingularBoolField(value: self.voucher, fieldNumber: 1)
    }
    if self.stripe != false {
      try visitor.visitSingularBoolField(value: self.stripe, fieldNumber: 2)
    }
    if self.vipps != false {
      try visitor.visitSingularBoolField(value: self.vipps, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AvailablePaymentProviders, rhs: Server_AvailablePaymentProviders) -> Bool {
    if lhs.voucher != rhs.voucher {return false}
    if lhs.stripe != rhs.stripe {return false}
    if lhs.vipps != rhs.vipps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
